# Python algorithms
Курс GeekBrains - Алгоритмы и структуры данных на Python
___
## Оглавление

1. [Введение в Алгоритмизацию и простые алгоритмы на Python](#1-Введение-в-Алгоритмизацию-и-простые-алгоритмы-на-Python)
2. [Циклы, рекурсия, функции](#2-Циклы,-рекурсия,-функции)
3. [Массивы](#3-Массивы)
4. [Эмпирическая оценка алгоритмов](#4-Эмпирическая-оценка-алгоритмов)
5. [Коллекции. Модуль Collections](#5-Коллекции\.-Модуль-Collections)


____
## 1\. Введение в Алгоритмизацию и простые алгоритмы на Python
1. Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. Выполнить над числом 5 побитовый сдвиг вправо и влево на два знака.
2. По введенным пользователем координатам двух точек вывести уравнение прямой вида y = kx + b, проходящей через эти точки.
3. Написать программу, которая генерирует в указанных пользователем границах:
    - случайное целое число,
    - случайное вещественное число,
    - случайный символ.
Для каждого из трех случаев пользователь задает свои границы диапазона. Например, если надо получить случайный символ от 'a' до 'f', то вводятся эти символы. Программа должна вывести на экран любой символ алфавита от 'a' до 'f' включительно.
4. Пользователь вводит две буквы. Определить, на каких местах алфавита они стоят, и сколько между ними находится букв. <br>
Примечания: во всех заданиях, где речь идёт о буквах алфавита, решения необходимы только для строчных букв латинского алфавита от a до z. <br>
Попытайтесь решить задания без использования циклов и собственных функций (они будут рассматриваться на уроке 2), а также без массивов (они будут рассматриваться на уроке 3).
Для простоты понимания зарезервированные слова `for` и `while` считаются циклом, `def` - функцией, любые квадратные скобки `[` и `]` - массивами. Их наличие в коде расценивается как неверное решение. <br>
Договариваемся об идеальном пользователе, который вводит только верные данные, которые требует программа. Проверка ввода не обязательна. Уделите это время в первую очередь построению графического алгоритма, а затем написанию кода по этому алгоритму. Не наоборот.

[Вернуться к Оглавлению](#Оглавление)
## 2\. Циклы, рекурсия, функции
1. Написать программу, которая будет складывать, вычитать, умножать или делить два числа. Числа и знак операции вводятся пользователем. После выполнения вычисления программа не завершается, а запрашивает новые данные для вычислений. Завершение программы должно выполняться при вводе символа '0' в качестве знака операции. Если пользователь вводит неверный знак (не '0', '+', '-', '', '/'), программа должна сообщать об ошибке и снова запрашивать знак операции. Также она должна сообщать пользователю о невозможности деления на ноль, если он ввел его в качестве делителя.
2. Посчитать четные и нечетные цифры введенного натурального числа. Например, если введено число 34560, в нем 3 четные цифры (4, 6 и 0) и 2 нечетные (3 и 5).
3. Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран. Например, если введено число 3486, надо вывести 6843.
4. Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,… Количество элементов (n) вводится с клавиатуры. <br>
Примечания: в заданиях 2, 3, 4 пользователь вводит только натуральные числа. <br>
Попытайтесь решить задания без использования массивов в любых вариациях (массивы будут рассмотрены на следующем уроке). Для простоты понимания любые квадратные скобки `[` и `]` считаются массивами и их наличие в коде расценивается как неверное решение. <br>
Договариваемся об идеальном пользователе, который вводит только верные данные, которые требует программа. Проверка ввода не обязательна. Уделите это время в первую очередь построению графического алгоритма, а затем написанию кода по этому алгоритму. Не наоборот.

[Вернуться к Оглавлению](#Оглавление)
## 3\. Массивы
1. В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9. Примечание: 8 разных ответов.
2. Во втором массиве сохранить индексы четных элементов первого массива. Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, второй массив надо заполнить значениями 0, 3, 4, 5 (помните, что индексация начинается с нуля), т. к. именно в этих позициях первого массива стоят четные числа.
3. В массиве случайных целых чисел поменять местами минимальный и максимальный элементы.
4. Определить, какое число в массиве встречается чаще всего.
5. В массиве найти максимальный отрицательный элемент. Вывести на экран его значение и позицию в массиве. <br>Примечание к задаче: пожалуйста не путайте «минимальный» и «максимальный отрицательный». Это два абсолютно разных значения. <br>
Примечание: попытайтесь решить задания без использования функций `max`, `min`, `sum`, `sorted` и их аналогов, в том числе написанных самостоятельно. <br>
В задачах 3, 4, 5 если искомый элемент(ы) встречается в массиве несколько раз, используйте один любой по вашему выбору.

[Вернуться к Оглавлению](#Оглавление)
## 4\. Эмпирическая оценка алгоритмов
1. Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
    - выбрать хорошую задачу, которую имеет смысл оценивать,
    - написать 3 варианта кода (один у вас уже есть),
    - проанализировать 3 варианта и выбрать оптимальный,
    - результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
    - написать общий вывод: какой из трёх вариантов лучше и почему.
2. Написать два алгоритма нахождения `i`-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов. <br>
Первый — с помощью алгоритма «Решето Эратосфена». Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу. <br>
Второй — без использования «Решета Эратосфена». Примечание. Вспомните классический способ проверки числа на простоту. <br>
Пример работы программ:
```python
{
    >>> sieve(2)
    3
    >>> prime(4)
    7
    >>> sieve(5)
    11
    >>> prime(1)
    2
}
```
Примечание по профилированию кода: для получения достоверных результатов при замере времени необходимо исключить/заменить функции `print()` и `input()` в анализируемом коде. С ними вы будете замерять время вывода данных в терминал и время, потраченное пользователем, на ввод данных, а не быстродействие самого алгоритма.

[Вернуться к Оглавлению](#Оглавление)
## 5\. Коллекции\. Модуль Collections
1. Пользователь вводит данные о количестве предприятий, их наименования и прибыль за четыре квартала для каждого предприятия. Программа должна определить среднюю прибыль (за год для всех предприятий) и отдельно вывести наименования предприятий, чья прибыль выше среднего и ниже среднего.
2. Написать программу сложения и умножения двух шестнадцатеричных чисел. При этом каждое число представляется как массив, элементы которого — цифры числа.
Например, пользователь ввёл A2 и C4F. Нужно сохранить их как `[‘A’, ‘2’]` и `[‘C’, ‘4’, ‘F’]` соответственно. Сумма чисел из примера: `[‘C’, ‘F’, ‘1’]`, произведение - `[‘7’, ‘C’, ‘9’, ‘F’, ‘E’]`. <br>
Примечание: Если воспользоваться функциями `hex()` и/или `int()` для преобразования систем счисления, задача решается в несколько строк. Для прокачки алгоритмического мышления такой вариант не подходит. Поэтому использование встроенных функций для перевода из одной системы счисления в другую в данной задаче под запретом. Вспомните начальную школу и попробуйте написать сложение и умножение в столбик.

[Вернуться к Оглавлению](#Оглавление)
